**Билет 1:**
Напишите метод под названием alternate, который принимает два списка целых чисел в качестве параметров
и возвращает новый список, содержащий чередующиеся элементы из двух списков, в следующем порядке:
Первый элемент из первого списка
Первый элемент из второго списка
Второй элемент из первого списка
Второй элемент из второго списка
Третий элемент из первого списка
Третий элемент из второго списка
Если списки не содержат одинаковое количество элементов, оставшиеся элементы из более длинного списка
должны быть расположены последовательно в конце. Например, для первого списка (1, 2, 3, 4, 5) и второго
списка (6, 7, 8, 9, 10, 11, 12) вызов alternate (listl, list2) должен вернуть список, содержащий (1, 6, 2, 7, 3, 8, 4,
9.5, 10, 11, 12). Не изменяйте передаваемые списки параметров.

**Билет 2:**
Напишите метод reverse, который принимает Мар от целых чисел к строкам в качестве параметра и
возвращает новый Мар из строк к целым числам, который является «зеркальным отображением»
оригинальной структуры. Риверс исходного Мар определяется здесь как новый Мар, который использует
значения из оригинала в качестве своих ключей и ключи от оригинала в качестве своих значений. Поскольку
значения Мар не обязательно должны быть уникальными, а его ключи обязательно должны быть
уникальными, допустимо иметь любой из исходных ключей в результате в качестве значения. Другими
словами, если исходный словарь имеет пары (k1, v) и (k2, v), то новый словарь должен содержать либо пару
(v, k1), либо (v, k2).

**Билет 3:**
Напишите метод isUnique, который принимает Мар <string, string> в качестве параметра и возвращает true,
если никакие два ключа не отображаются на одно и то же значение (и false, если любые два или более ключа
соответствуют одному и тому же значению). Например, вызов вашего метода на следующем словаре вернет
{Marty=Stepp, Stuart=Reges, Jessica=Miller, Amanda=Camp, Hal=Perkins}
Вызов его на следующем словаре вернул бы false из-за двух отображений для Perkins и Reges:
{Kendrick=Perkins, Stuart-Reges, Jessica=Miller, Bruce=Reges, Hal=Perkins}
Пустой словарь считается уникальным, поэтому ваш метод должен возвращать true, если передается пустой
словарь.

**Билет 4:**
Напишите метод hasOdd, который принимает множество (Set) целых чисел в качестве параметра и возвращает
true, если набор содержит хотя бы одно нечетное целое число, и false в противном случае. Если передано
пустое множество, ваш метод должен вернуть false.

**Билет 5:**
Напишите метод rarest, который принимает Мар, ключи которого являются строками, а значения являются
целыми числами, в качестве параметра. Метод возвращает целочисленное значение, которое встречается в
словаре наименьшее количество раз. Если словарь не пуст, то верните меньшее целочисленное значение. Если
словарь пуст, сгенерируйте исключение.
Например, предположим, что словарь содержит сопоставления имен студентов(строки) и их возраста (целые
числа). Ваш метод вернет наименее часто встречающийся возраст. Рассмотрим переменную словаря м.
содержащую следующие пары ключ/значение:
(Alyssa=22, Char=25, Dan-25, Jeff-20, Kasey 20, Kim-20, Mogran-25, Ryan=25, Stef-22)
Три человека имеют возраст 20 лет (Джефф. Кейси и Ким), и два человека - 22 года (Алисса и Стеф), и четыре
человека - 25 лет (Чар, Дэн, Могран и Райан). Таким образом, сетод rarest (м) возвращает 22, потому что
только два человека имеют этот возраст.

**Билет 6:**
Напишите метод с именем guavaSort, который принимает массив строк в качестве параметра и упорядочивает строки в массиве в отсортированном порядке возрастания. В частности, ваш алгоритм сортировки должен использовать FJC для Multiset или Multimap для реализации варианта алгоритма блочной сортировки, который будет работать со строками. Используйте коллекцию FJC для подсчета вхождений строк, аналогично тому, как это делается в блочной сортировке, а затем поместите эти строки обратно в массив отсортированном порядке. Например, предположим, что вашему методу передается следующий массив: [Farm, Zoo, Car, Apple, Bee, Golf, Bee, Dog, Golf, Zoo, Zoo, Bee, Bee, Apple] Ваша коллекция должна хранить следующие вхождения строк:
[Apple x 2, Bee x 4, Car, Dog, Farm, Golf x 2, Zoo x 3]
B
Что вы должны использовать, чтобы поместить строки обратно в массив в отсортированном порядке: [Apple, Apple, Bee, Bee, Bee, Bee, Car, Dog, Farm, Golf, Golf, Zoo, Zoo, Zoo]
Ваш код должен выполняться за время O (N log N) и использовать память О (N), где N - количество элементов в массиве. Вы можете предположить, что переданный массив и все строки в нем не равны нулю. Не используйте никаких других вспомогательных коллекций, кроме одного Multiset или Multimap.

**Билет 7:**
Напишите метод removeAll, который можно добавить в класс LinkedIntList. Метод должен эффективно удалить из отсортированного списка целых чисел все значения, появляющиеся во втором отсортированном списке целых чисел. Например, предположим, что переменные LinkedIntList list1 и list2 ссылаются на следующие списки:
listl: [1, 3, 5, 7]
list2: [1, 2, 3, 4, 5]
Если была вызвана list1.removeAll (list2); то, списки должны хранить следующие значения после вызова: list]: [7]
list2: [1, 2, 3, 4, 5]
Обратите внимание, что все значения из listl, которые появляются в list2, были удалены, а list2 не изменился. Если бы вместо этого был вызов list2.removeAll (list1); списки будут иметь следующие значения: list1: [1, 3, 5, 7]
list2: [2,4]
Оба списка гарантированно находятся в отсортированном (неубывающем) порядке, хотя в любом списке могут быть дубликаты. Поскольку списки отсортированы, вы можете решить эту проблему очень эффективно за один проход данных. Ваше решение должно выполняться за время О (М + N), где М и N - длины двух списков. Предположим, что мы добавляем этот метод в класс LinkedIntList, как показано ниже. Вы не можете вызывать какие-либо другие методы класса для решения этой задачи, вы не можете создавать новые узлы и не можете использовать какие-либо вспомогательные структуры данных для решения этой проблемы (например, массив, ArrayList, Queue, String и т. Д.). Вы также не можете изменять какие-либо поля данных узлов. Вы должны решить эту задачу, переставив ссылки на списки. public class LinkedIntList {
private ListNode front;
}
}
public class ListNode {
public int data; public ListNode next;

**Билет 9:**
Напишите метод removeDuplicates, который можно добавить в класс LinkedIntList. Метод должен удалить любые дубликаты из связанного списка целых чисел. Результирующий список должен иметь значения в том же относительном порядке, что и их первое вхождение в исходном списке. Другими словами, значение і должно появляться перед значением и в окончательном списке тогда и только тогда, когда первое вхождение і появилось до первого появления j в исходном списке. Например, если переменная с именем list хранит следующий список: [14, 8, 14, 12, 1, 14, 11, 8, 8, 10, 4, 9, 1, 2, 5, 2, 4, 12, 12]
После вызова list.removeDuplicates (); список должен хранить эти значения в таком виде: [14, 8, 12, 1, 11, 10, 4, 9, 2, 5]
Предположим, что мы добавляем этот метод в класс LinkedIntList, как показано ниже. Вы не можете вызывать какие-либо другие методы класса для решения этойзадачи, вы не можете создавать новые узлы и не можете использовать какие-либо вспомогательные структуры данных для решения этой проблемы (например, массив, ArrayList, Queue, String и т. д.). Вы также не можете изменять какие-либо поля данных узлов. Вы должны решить этузадачу, переставив ссылки в списке.
public class LinkedIntList {
}
private ListNode front;
public class ListNode {
public int data; public ListNode next;
}

**Билет 10:**
Напишите метод splitStack, который принимает стек целых чисел в качестве параметра и разбивает его на отрицательные и неотрицательные значения. Числа в стеке должны быть переставлены так, чтобы все отрицательные значения появлялись в нижней части стека, а все неотрицательные - в верхней части. Другими словами, если после вызова этого метода вам нужно будет вытолкнуть числа из стека, вы сначала получите все неотрицательные числа, а затем получите все отрицательные числа. Неважно, в каком порядке появляются числа, если все отрицательные находятся в стеке всегда ниже, чем все неотрицательные числа. Вы можете использовать одну очередь в качестве вспомогательного хранения.

**Билет 11:**
Напишите метод firstLast, который можно добавить в класс LinkedIntList, который перемещает первый элемент списка в конец списка. Предположим, что переменная LinkedIntList с именем list хранит следующие элементы спереди (слева) и сзади (справа):
[18, 4, 27, 9, 54, 5, 63]
Если вы сделали вызов list. firstLast ();, список будет хранить элементы в следующем порядке: [4, 27, 9, 54, 5, 63, 18]
Если список пуст или содержит только один элемент, его содержимое не должно изменяться. Соблюдайте следующие ограничения в вашем решении:
Не вызывайте никакие другие методы объекта LinkedIntList, такие как add, remove или size.
Не создавайте новые объекты ListNode (хотя у вас может быть столько переменных ListNode, сколько вам нужно). Не используйте другие структуры данных, такие как массивы, списки, очереди и т. д. Не изменяйте данные любого существующего узла; изменять список только путем изменения ссылок между узлами.
Ваше решение должно выполняться за время (N), где N количество элементов в связанном списке. Предположим, что вы добавляете этот метод в класс LinkedIntList (который использует класс ListNode) как показано ниже:
public class LinkedIntList {
public class ListNode {
public int data;
}
public ListNode next;

**Билет 14:**
Напишите метод equals, который принимает в качестве параметров два стека целых чисел, метод возвращает true, если два стека равны, и в противном случае возвращает false. Чтобы считаться равными, два стека должны хранить одинаковую последовательность целочисленных значений в одном и том же порядке. Ваш метод заключается в проверке двух стеков, но перед завершением работы метода необходимо вернуть их в исходное состояние. Вы можете использовать один стек в качестве вспомогательного хранения.

**Билет 15:**
Напишите метод splitStack, который принимает стек целых чисел в качестве параметра и разбивает его на отрицательные и неотрицательные значения. Числа в стеке должны быть переставлены так, чтобы все отрицательные значения появлялись в нижней части стека, а все неотрицательные в верхней части. Другими словами, если после вызова этого метода вам нужно будет вытолкнуть числа из стека, вы сначала получите все неотрицательные числа, а затем получите все отрицательные числа. Неважно, в каком порядке появляются числа, если все отрицательные находятся в стеке всегда ниже, чем все неотрицательные числа. Вы можете использовать одну очередь в качестве вспомогательного хранения.

**Билет 15 (New):**
Напишите метод reverseHalf, который меняет порядок на половину элементов очереди целых чисел. Ваш метод должен изменить порядок всех элементов в нечетных позициях (позиции 1, 3, 5 и т.д.), помним, что первое значение в очереди имеет позицию 0. Например, если очередь изначально хранит эту последовательность числе, когда метод вызывается:
index: 0 1 2 3 4 5 6 7
front [1, 8, 7, 2, 9, 18, 12, 0] back
Очередь должна хранить следующие значения выполнения метода:
index 0 1 2 3 4 5 6 7
front [1, 0, 7, 18, 9, 2, 12, 8] back
Обратите внимание, что числа в четных позициях (позиции 0, 2, 4, 6) не сместились. Эта последовательности чисел по-прежнему: (1, 7, 9, 12). Но обратите внимание, что числа в нечетных позициях (позиции 1, 3, 5, 7) теперь в обратном порядке относительно оригинала. Другими словами, исходная подпоследовательность: (8, 2, 18, 0) — стала такой: (0, 18, 2, 8). Вы можете использовать стек в качестве вспомогательного хранения элементов.

**Билет 16:**
Напишите метод copyStack, который принимает стек целых чисел в качестве параметра и возвращает копию оригинального стека (то есть новый стек с теми же значениями, что и у оригинала, сохраненный в том же порядке, что и оригинал). Ваш метод должен создать новый стек и заполнять его теми же значениями, которые хранятся в исходном стеке. Недопустимо возвращать тот же стек, переданный методу; Вы должны создать, заполнить и вернуть новый стек. Вы будете удалять значения из исходного стека, чтобы сделать копию, но вы должны быть уверены, что поместите их обратно в исходный стек в том же порядке, прежде чем завершите с ним работу. Другими словами, когда ваш метод будет выполнен, исходный стек должен быть восстановлен в неходное состояние, и вы вернете новый независимый стек, который находится в том же состоянии. Вы можете использовать одну очередь в качестве вспомогательного хранения.

**Новый билет 16:** Класс Деньги для работы с денежными суммами. Число должно быть представлено двумя полями: типа long
для рублей и типа double- для копеек. Дробная часть (копейки) при выводе на экран должна быть отделена от
целой части запятой. Реализовать сложение, вычитание, деление сумм, деление суммы на дробное число,
умножение на дробное число и операции сравнения. В классе Тестер проверить эти методы.

**Билет 18:**
Напишите метод longestSortedSequence, который возвращает длину самой длинной отсортированной последовательности в списке целых чисел. Например, если переменная с именем list хранит следующую последовательность значений:
[1, 3, 5, 2, 9, 7, -3, 0, 42, 308, 17]
тогда
вызов: list.longestSortedSequence () вернет значение 4, поскольку это длина самой длинной отсортированной последовательности в этом списке (последовательность -3, 0, 42, 308). Если список пуст, ваш метод должен вернуть 0. Обратите внимание, что для непустого списка метод всегда будет возвращать по крайней мере 1, потому что любой отдельный элемент составляет отсортированную
значение
последовательность.
public class ArrayIntList {
private int[] elementData; private int size;
// your code goes here
}

**Билет 21:**
Напишите универсальный класс для реализации алгоритмов поиска. В качества параметров используйте
массив интерфейсных ссылок

**Билет 22:**
Напишите универсальный класс для реализации алгоритмов сортировок. В качества параметров используйте массив интерфейсных ссылок

**Билет 23:**
Разработайте класс иерархию классов Геометрическая фигура, Прямоугольник, Круг. Используйте паттерн Фабрика

**Билет 24:**
Разработайте класс иерархию классов Комплексное число, Рациональное число. Используйте паттерн Фабрика

**Билет 25:**
Напишите реализацию структуры данных Stack на списке

**Билет 26:**
Напишите реализацию структуры ArrayList на списке

**Билет 27:**
Напишите реализацию структуры ArrayList на массиве.

**Билет 28:**
Дано натуральное число N. Вычислите сумму его цифр.
При решении этой задачи нельзя использовать строки, списки, массивы (ну и циклы, разумеется).

**Билет 29:**
Напишите реализацию структуры данных Stack на массиве. При реализации необходимо использовать Дженерики

**Билет 30:**
Задача на рекурсию: Дано натуральное число N. Выведите слово YES, если число N является точной степенью двойки, или слово NO в противном случае. Операцией возведения в степень пользоваться нельзя!
